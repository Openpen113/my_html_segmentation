<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>音檔對話分段播放器（iPhone 兼容版｜精準＋不變音高）</title>
<style>
  :root{ --bg:#f3f4f6;--card:#fff;--text:#0f172a;--muted:#6b7280;
         --primary:#2563eb;--primary-2:#1d4ed8;--played:#10b981;--played-2:#059669;
         --border:#e5e7eb;--shadow:0 10px 24px rgba(0,0,0,.06) }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans TC",sans-serif}
  .wrap{max-width:640px;margin:0 auto;padding:16px}
  .h1{font-size:22px;font-weight:800;margin:12px 0}
  .hint{font-size:12px;color:var(--muted);margin-bottom:12px}
  .card{background:var(--card);border-radius:16px;box-shadow:var(--shadow);padding:16px;margin-bottom:16px}
  input[type=file]{width:100%;padding:12px;border:1px solid var(--border);border-radius:12px;background:#fff}
  textarea{width:100%;min-height:140px;padding:12px;border:1px solid var(--border);border-radius:12px;resize:vertical;background:#fff;font:14px/1.5 ui-sans-serif,system-ui,"Noto Sans TC",sans-serif}
  .status{min-height:24px;margin:12px 0 14px;font-size:14px;text-align:center;color:var(--muted)}
  .status.ok{color:#16a34a}.status.err{color:#dc2626}.status.info{color:#2563eb}
  .section-title{font-weight:700;margin:10px 0}
  .segments{display:grid;gap:10px}
  .segwrap{display:flex;flex-direction:column;gap:8px}
  .segbtn{width:100%;padding:14px 16px;border:0;border-radius:14px;background:var(--primary);color:#fff;font-weight:800;letter-spacing:.3px;box-shadow:var(--shadow);font-size:16px}
  .segbtn:active{transform:scale(.98)} .segbtn:hover{background:var(--primary-2)}
  .segbtn.played{background:var(--played)} .segbtn.played:hover{background:var(--played-2)}
  .segtext{background:#f8fafc;border:1px solid var(--border);border-radius:12px;padding:10px 12px;color:#0b3a62;font-size:14px;white-space:pre-wrap}
  details{background:#fff;border-radius:16px;box-shadow:var(--shadow);padding:12px}
  summary{cursor:pointer;list-style:none} summary::-webkit-details-marker{display:none}
  .row{margin:12px 0} .range{width:100%} .num{font:600 20px/1.2 ui-monospace,Menlo,Consolas,monospace}
  .ctlrow{display:flex;align-items:center;justify-content:center;gap:16px}
  .ctlbtn{width:56px;height:56px;border-radius:50%;border:0;background:#e5e7eb;font-weight:900;font-size:26px;box-shadow:var(--shadow)}
  .ctlbtn:active{transform:scale(.97);filter:brightness(.95)}
  .btn{display:inline-flex;align-items:center;justify-content:center;width:100%;padding:14px;border-radius:14px;border:0;box-shadow:var(--shadow);font-weight:800;cursor:pointer}
  .btn.primary{background:#2563eb;color:#fff} .btn.primary:hover{background:#1d4ed8}
  .btn.gray{background:#e5e7eb;color:#111827}
  .btn.toggle-on{background:#0ea5e9;color:#fff}
  .btn.inline{display:inline-block;width:auto;padding:10px 12px;border-radius:10px}
</style>
</head>
<body>
<div class="wrap">
  <h1 class="h1">音檔對話分段播放器</h1>
  <p id="hint" class="hint">
    iPhone：先點「🔓啟用音訊」，再選檔。若檔案在「語音備忘錄」，先分享到「檔案」App 再選。
  </p>

  <div class="card">
    <div class="row">
      <button id="unlockBtn" class="btn inline primary">🔓 啟用音訊</button>
      <span class="hint" id="unlockHint">未解鎖</span>
    </div>

    <label for="file"><b>選擇音訊檔</b>（移除了 accept 限制，避免檔案被灰掉）</label>
    <!-- ★★★ 重要：移除 accept，讓 iOS 不會把某些音檔灰掉 ★★★ -->
    <input id="file" type="file">

    <div id="status" class="status">請先點上方「啟用音訊」，再選擇音檔。</div>
  </div>

  <div class="card">
    <h2 class="section-title">逐字稿（可貼上多段，含 A:/B: 也可以）</h2>
    <textarea id="transcript" placeholder="在這裡貼上逐字稿…"></textarea>
    <div class="row"><small class="hint">會用 10ms 能量估計把字數分配到各分段，並就近貼齊標點/換行。</small></div>
    <div class="row">
      <button id="applyTranscript" class="btn primary">套用逐字稿到分段（能量近似）</button>
      <button id="clearTranscript" class="btn gray" style="margin-top:12px">清空逐字稿</button>
    </div>
  </div>

  <div class="card">
    <h2 class="section-title">分段結果</h2>
    <div id="segments" class="segments"></div>
  </div>

  <div class="card">
    <details open>
      <summary><b>進階設定</b></summary>

      <div class="row">
        <button id="speedBtn" class="btn gray">速度：正常 x1.0（點此切換 0.8x，不變音高）</button>
        <div class="hint" style="margin-top:8px">0.8x 會先以 WSOLA 進行時伸縮（保音高），再精準播放切片。</div>
      </div>

      <div class="row">
        <label>靜音音量閾值：<span id="vThr" class="num">0.05</span></label>
        <input id="thr" type="range" min="0.01" max="0.5" step="0.01" value="0.05" class="range">
      </div>

      <div class="row">
        <label>最短靜音間隔（毫秒）</label>
        <div class="ctlrow">
          <button id="minus" class="ctlbtn">–</button>
          <span id="vSil" class="num" style="min-width:72px;text-align:center">120</span>
          <button id="plus"  class="ctlbtn">+</button>
        </div>
      </div>

      <div class="row">
        <label>最短對話長度（毫秒）：<span id="vSeg" class="num">500</span></label>
        <input id="seg" type="range" min="200" max="5000" step="100" value="500" class="range">
      </div>

      <div class="row">
        <button id="reanalyze" class="btn primary">重新分析（並清除綠色標記）</button>
        <button id="clear" class="btn gray" style="margin-top:12px">清除本機記錄</button>
      </div>
    </details>
  </div>
</div>

<script>
/* ===== DOM ===== */
const fileEl = document.getElementById('file');
const statusEl = document.getElementById('status');
const segmentsEl = document.getElementById('segments');
const thrEl = document.getElementById('thr'), vThr = document.getElementById('vThr');
const segEl = document.getElementById('seg'), vSeg = document.getElementById('vSeg');
const vSil = document.getElementById('vSil'), minus = document.getElementById('minus'), plus = document.getElementById('plus');
const speedBtn = document.getElementById('speedBtn');
const reBtn = document.getElementById('reanalyze'), clrBtn = document.getElementById('clear');
const transcriptEl = document.getElementById('transcript');
const applyTrBtn = document.getElementById('applyTranscript'); const clearTrBtn = document.getElementById('clearTranscript');
const hintEl = document.getElementById('hint');
const unlockBtn = document.getElementById('unlockBtn'); const unlockHint = document.getElementById('unlockHint');

/* ===== Helpers ===== */
function setStatus(t,c){ statusEl.textContent=t; statusEl.className='status '+(c||''); }
function fmt(s){ return new Date(s*1000).toISOString().substr(11,8); }
vThr.textContent=thrEl.value; vSeg.textContent=segEl.value;

/* ===== WebAudio ===== */
const AC = window.AudioContext || window.webkitAudioContext;
let ctx=null;
async function ensureCtx(){
  if(!ctx) ctx = new AC();
  if(ctx.state === 'suspended') await ctx.resume();
  // 播一個 sample 的靜音，確保 iOS 授權輸出
  const b = ctx.createBuffer(1, 1, ctx.sampleRate);
  const src = ctx.createBufferSource(); src.buffer = b; src.connect(ctx.destination); try{ src.start(0); }catch{}
}
unlockBtn.onclick = async ()=>{
  try{
    await ensureCtx();
    unlockHint.textContent = '已解鎖';
    unlockBtn.textContent = '✅ 已啟用';
    unlockBtn.classList.add('toggle-on');
    setStatus('音訊已解鎖，請選擇音檔。','ok');
  }catch(e){
    setStatus('無法解鎖音訊，請再點一次或重整頁面。','err');
  }
};

/* ===== 狀態 ===== */
let audioUrl=null, audioBuf=null, currentSrc=null;
let segments=[], segmentTexts=[];
let played=new Set(); let storageKey='', lastMeta=null;
let slowMode=false;
const stretchCache = new Map();

/* ===== 檔名提示 ===== */
(function(){ const lastName=localStorage.getItem('segmenter:lastName'); if(lastName){ hintEl.textContent=`上次使用檔案：${lastName}。請再次選同一檔，我會自動恢復設定與已播放標記。`; }})();

/* ===== Storage ===== */
function saveState(){
  if(!storageKey) return;
  const st={ params:{thr:+thrEl.value,sil:parseInt(vSil.textContent,10)||120,seg:parseInt(segEl.value,10)||500,rate:slowMode?0.8:1.0},
    played:[...played], transcript: transcriptEl.value||'', segTexts:segmentTexts };
  localStorage.setItem(storageKey, JSON.stringify(st));
  localStorage.setItem('segmenter:lastName', lastMeta?.name || '');
}
function loadState(key){ try{ return JSON.parse(localStorage.getItem(key)||'null'); }catch{ return null; } }

/* ===== 速度 ===== */
function refreshSpeedUI(){ speedBtn.classList.toggle('toggle-on', slowMode); speedBtn.textContent = slowMode?'速度：慢速 x0.8（不變音高）':'速度：正常 x1.0（不變音高）'; }
speedBtn.onclick=()=>{ slowMode=!slowMode; refreshSpeedUI(); saveState(); };

/* ===== 參數 ===== */
thrEl.addEventListener('input', ()=> vThr.textContent = thrEl.value );
segEl.addEventListener('input', ()=> vSeg.textContent = segEl.value );
minus.addEventListener('click', ()=>{ const v=parseInt(vSil.textContent,10)||120; vSil.textContent=Math.max(100, v-20); saveState(); });
plus .addEventListener('click', ()=>{ const v=parseInt(vSil.textContent,10)||120; vSil.textContent=Math.min(3000, v+20); saveState(); });

/* ===== 解碼（移除 accept 後，仍做 iOS 友善處理） ===== */
async function decodeAudioFile(file){
  await ensureCtx(); // ★ 先解鎖
  let ab=null;
  try{ ab = await file.arrayBuffer(); }
  catch(e){ throw new Error('讀取檔案失敗，請重試或改用 WAV。'); }

  try{
    if (ctx.decodeAudioData.length === 1) {
      return await ctx.decodeAudioData(ab.slice(0));
    } else {
      return await new Promise((res, rej)=> ctx.decodeAudioData(ab.slice(0), res, rej));
    }
  }catch(e){
    console.error('decodeAudioData 失敗：', e);
    throw new Error('無法解碼此音檔。建議：① 先點「啟用音訊」再選檔；② 改用 .wav；③ 先把檔案存到「檔案」App 本機再選。');
  }
}

/* ===== 載入檔案 ===== */
fileEl.onchange = async e=>{
  const f=e.target.files[0]; if(!f) return;

  if(audioUrl) URL.revokeObjectURL(audioUrl);
  audioUrl=URL.createObjectURL(f);

  setStatus('正在解碼音檔…');
  try{
    audioBuf = await decodeAudioFile(f);
  }catch(err){
    setStatus(err.message || '解碼失敗。', 'err');
    return;
  }

  storageKey=`segmenter:${f.name}:${f.size}`; lastMeta={name:f.name,size:f.size};
  stretchCache.clear();
  played.clear();

  const saved=loadState(storageKey);
  if(saved && saved.params){
    thrEl.value=saved.params.thr??0.05; vThr.textContent=thrEl.value;
    vSil.textContent=saved.params.sil??120;
    segEl.value=saved.params.seg??500; vSeg.textContent=segEl.value;
    slowMode=(saved.params.rate??1)!==1; refreshSpeedUI();
    transcriptEl.value=saved.transcript||''; segmentTexts=Array.isArray(saved.segTexts)?saved.segTexts:[];
    (saved.played||[]).forEach(i=>played.add(i));
    setStatus(`已恢復上次設定、逐字稿與已播放記錄（${f.name}）。`,'info');
  }else{
    slowMode=false; refreshSpeedUI(); transcriptEl.value=''; segmentTexts=[];
    setStatus('載入完成。','ok');
  }
  analyzeAndRender(); saveState();
};

/* ===== 重新分析 / 清除 ===== */
document.getElementById('reanalyze').onclick=()=>{ if(!audioBuf) return setStatus('請先上傳音檔。','err'); played.clear(); analyzeAndRender(); if(transcriptEl.value.trim()) energyAttachTranscript(); saveState(); };
document.getElementById('clear').onclick=()=>{ if(storageKey) localStorage.removeItem(storageKey); played.clear(); transcriptEl.value=''; segmentTexts=[]; analyzeAndRender(); setStatus('已清除本機記錄。'); };

/* ===== 逐字稿 ===== */
document.getElementById('applyTranscript').onclick=()=>{ if(!audioBuf) return setStatus('請先上傳音檔後再套用逐字稿。','err'); energyAttachTranscript(); renderSegments(segments); setStatus('已用能量近似把逐字稿分配至各分段。','ok'); saveState(); };
document.getElementById('clearTranscript').onclick=()=>{ transcriptEl.value=''; segmentTexts=[]; renderSegments(segments); saveState(); };

/* ===== 分析 & 顯示 ===== */
function analyzeAndRender(){
  if(!audioBuf){ segmentsEl.innerHTML=''; return; }
  setStatus('正在分析音檔…');
  const thr=Number(thrEl.value); const sil=parseInt(vSil.textContent,10); const seg=parseInt(segEl.value,10);
  segments=segmentAudio(audioBuf,{ thr:Number.isFinite(thr)?thr:0.05, sil:Number.isFinite(sil)?sil:120, seg:Number.isFinite(seg)?seg:500 });
  if(!segments.length){ segmentsEl.innerHTML=''; setStatus('未偵測到任何段落，請調整參數後重試。','err'); return; }
  setStatus(`分析完成！共偵測到 ${segments.length} 個對話段落。`,'ok');
  if(transcriptEl.value.trim() && segmentTexts.length!==segments.length){ energyAttachTranscript(); }
  renderSegments(segments);
}

function segmentAudio(buf,opt){
  const ch=buf.getChannelData(0), sr=buf.sampleRate;
  const thr=opt.thr, minSil=Math.floor(opt.sil/1000*sr), minSeg=Math.floor(opt.seg/1000*sr);
  let out=[], lastEnd=0, silStart=-1;
  const W=8; let acc=0, win=new Array(W).fill(0), wi=0;
  for(let i=0;i<ch.length;i++){
    const a=Math.abs(ch[i]); acc-=win[wi]; acc+=a; win[wi]=a; wi=(wi+1)%W;
    const vol=acc/W, isSilence=vol<thr;
    if(isSilence){ if(silStart===-1) silStart=i; }
    else if(silStart!==-1){
      const silDur=i-silStart;
      if(silDur>=minSil){ const s=lastEnd,e=silStart,len=e-s; if(len>=minSeg) out.push({start:s/sr,end:e/sr}); lastEnd=i; }
      silStart=-1;
    }
  }
  const tail=ch.length-lastEnd;
  if(tail>=Math.max(1,Math.floor(minSeg*0.5))) out.push({start:lastEnd/sr,end:ch.length/sr});
  out=out.map(s=>({start:Math.max(0,s.start),end:Math.max(0,s.end)})).filter(s=>s.end-s.start>1e-3);
  for(let i=1;i<out.length;i++){ if(out[i].start<out[i-1].end) out[i].start=out[i-1].end; }
  return out;
}

function renderSegments(list){
  segmentsEl.innerHTML='';
  list.forEach((seg,i)=>{
    const wrap=document.createElement('div'); wrap.className='segwrap';
    const btn=document.createElement('button'); btn.className='segbtn';
    btn.textContent=`播放對話 #${i+1}（${fmt(seg.start)} - ${fmt(seg.end)}）`;
    if(played.has(i)) btn.classList.add('played');
    btn.onclick=()=>{ playSegment(seg.start,seg.end); btn.classList.add('played'); played.add(i); saveState(); };
    wrap.appendChild(btn);
    const txt=document.createElement('div'); txt.className='segtext'; txt.textContent=segmentTexts[i]||''; wrap.appendChild(txt);
    segmentsEl.appendChild(wrap);
  });
}

/* ===== 能量近似把逐字稿分配到各段 ===== */
function energyAttachTranscript(){
  const full=(transcriptEl.value||'').trim(); if(!full){ segmentTexts=new Array(segments.length).fill(''); return; }
  const tokens=tokenizeWords(full); const W=tokens.length; if(W===0){ segmentTexts=new Array(segments.length).fill(''); return; }
  const E=computeFrameEnergy(audioBuf); const segEner=segments.map(seg=>sumEnergyFor(seg,E));
  let total=segEner.reduce((a,b)=>a+b,0); if(total<=1e-9) total=segEner.length;
  let alloc=segEner.map(e=>Math.round(W*(e/total)));
  let diff=W-alloc.reduce((a,b)=>a+b,0), idx=0; while(diff>0){ alloc[idx%alloc.length]++; idx++; diff--; }
  idx=0; while(diff<0){ const j=idx%alloc.length; if(alloc[j]>0){ alloc[j]--; diff++; } idx++; }
  const boundaries=[]; let running=0;
  for(let i=0;i<alloc.length-1;i++){ running+=alloc[i]; const snapped=snapBoundaryToPunctuation(tokens,running,8); boundaries.push(snapped); running=snapped; }
  boundaries.push(W);
  let start=0; segmentTexts=alloc.map((n,i)=>{ const end=boundaries[i]; const slice=tokens.slice(start,end); start=end; return detokenize(slice); });
}
function tokenizeWords(text){ const withNL=text.replace(/\r/g,'').replace(/\n/g,' ¶ ');
  const spaced=withNL.replace(/([，。！？；：、.,!?;:])/g,' $1 ').replace(/\s+/g,' ').trim(); return spaced.split(' ').filter(Boolean); }
function detokenize(tokens){ let s=tokens.join(' '); s=s.replace(/\s*¶\s*/g,'\n'); s=s.replace(/\s+([，。！？；：、.,!?;:])/g,'$1'); s=s.replace(/\n\s+/g,'\n'); return s.trim(); }
function snapBoundaryToPunctuation(tokens,pos,win){ const N=tokens.length; const L=Math.max(1,pos-win), R=Math.min(N-1,pos+win);
  let best=pos, d=1e9; for(let i=L;i<=R;i++){ if(tokens[i]==='¶'){ const di=Math.abs(i-pos); if(di<d){ d=di; best=i; } } } if(d!==1e9) return best;
  const P=new Set(['。','！','？','，','；','：','.',',','!','?',';']); best=pos; d=1e9;
  for(let i=L;i<=R;i++){ if(P.has(tokens[i])){ const di=Math.abs(i-pos); if(di<d){ d=di; best=i; } } } return d!==1e9 ? best+1 : pos; }
function computeFrameEnergy(buf){ const sr=buf.sampleRate, hop=Math.max(1,Math.round(sr*0.01)); const ch=buf.getChannelData(0);
  const frames=Math.floor(ch.length/hop); const energies=new Float32Array(frames); let idx=0;
  for(let f=0; f<frames; f++){ let sum=0; for(let i=0;i<hop;i++){ sum+=Math.abs(ch[idx+i]||0); } energies[f]=sum/hop; idx+=hop; }
  const smooth=new Float32Array(frames); const W=5; let acc=0; for(let i=0;i<frames;i++){ acc+=energies[i]; if(i>=W) acc-=energies[i-W]; smooth[i]=acc/Math.min(W,i+1); }
  let max=1e-9; for(let i=0;i<frames;i++) if(smooth[i]>max) max=smooth[i]; for(let i=0;i<frames;i++) smooth[i]/=max; return { sr, hop, energies, smooth }; }
function sumEnergyFor(seg,E){ const sF=Math.max(0,Math.floor(seg.start*E.sr/E.hop)); const eF=Math.min(E.smooth.length,Math.ceil(seg.end*E.sr/E.hop));
  let sum=0; for(let i=sF;i<eF;i++) sum+=E.smooth[i]; return sum+1e-6; }

/* ===== WSOLA：0.8x 不變音高 ===== */
function hannWindow(N){ const w=new Float32Array(N); for(let i=0;i<N;i++) w[i]=0.5*(1-Math.cos(2*Math.PI*i/(N-1))); return w; }
const HANN_2048 = hannWindow(2048);
function wsolaStretchSegment(buf, startSec, endSec, ratio){
  const sr = buf.sampleRate;
  const sS = Math.floor(startSec*sr), eS = Math.floor(endSec*sr);
  const inLen = Math.max(0, eS - sS);
  if (inLen <= 0) return null;
  const chs = buf.numberOfChannels;
  const seg = Array.from({length:chs}, (_,c)=> buf.getChannelData(c).subarray(sS, eS));
  const frame = 2048, hopA = 512;
  const ratioSafe = Math.max(0.5, Math.min(1.5, ratio));
  const hopS = Math.max(1, Math.round(hopA/ratioSafe));
  const search = 400;
  const outLen = Math.ceil(inLen/ratioSafe + frame);
  const out = Array.from({length:chs}, ()=> new Float32Array(outLen));
  let outWrite = 0, aPos = 0, initialized = false;
  while (aPos + frame < inLen) {
    let aStart = aPos;
    if (!initialized) {
      for (let c=0;c<chs;c++){ const src = seg[c], o = out[c]; for (let i=0;i<frame;i++) o[outWrite+i] += src[i]*HANN_2048[i]; }
      outWrite += hopS; aPos += hopA; initialized = true; continue;
    }
    const refStart = outWrite, refWin = frame;
    let bestOffset = 0, bestScore = -Infinity;
    const srcL = seg[0], refL = out[0];
    const searchStart = Math.max(0, aPos - search);
    const searchEnd   = Math.min(inLen - frame - 1, aPos + search);
    for (let cand = searchStart; cand <= searchEnd; cand += 4) {
      let s=0; for (let i=0;i<refWin;i++){ const x = refL[refStart + i] || 0; const y = srcL[cand + i] || 0; s += x*y; }
      if (s > bestScore){ bestScore = s; bestOffset = cand - aPos; }
    }
    aStart = aPos + bestOffset;
    for (let c=0;c<chs;c++){ const src = seg[c], o = out[c]; for (let i=0;i<frame;i++){ const v = src[aStart + i] || 0; o[outWrite + i] += v * HANN_2048[i]; } }
    outWrite += hopS; aPos += hopA;
  }
  const outLenUsed = Math.min(outLen, outWrite + frame);
  const norm = new Float32Array(outLenUsed);
  for (let i=0;i<outLenUsed;i++) norm[i]=0;
  for (let pos=0; pos<outWrite; pos+=hopS){ for (let i=0;i<frame && pos+i<outLenUsed;i++){ norm[pos+i] += HANN_2048[i]; } }
  for (let c=0;c<chs;c++){ const o = out[c]; for (let i=0;i<outLenUsed;i++){ const g = norm[i] > 1e-6 ? (1/norm[i]) : 1; o[i] = o[i]*g; } }
  const outBuf = (ctx || new (window.AudioContext||window.webkitAudioContext)()).createBuffer(chs, outLenUsed, sr);
  for (let c=0;c<chs;c++) outBuf.getChannelData(c).set(out[c].subarray(0, outLenUsed));
  return outBuf;
}

/* ===== 播放（精準＋不變音高） ===== */
function stopPlay(){ try{ if(currentSrc){ currentSrc.stop(); currentSrc.disconnect(); currentSrc=null; } }catch{} }
async function playSegment(start, end){
  if(!audioBuf) return;
  await ensureCtx(); stopPlay();
  const sr = audioBuf.sampleRate;
  const key = `${Math.floor(start*sr)}-${Math.floor(end*sr)}-${slowMode?0.8:1.0}`;
  let segBuf = null;
  if (slowMode) {
    if (stretchCache.has(key)) segBuf = stretchCache.get(key);
    else { setStatus('正在產生 0.8x（不變音高）音訊…','info'); await new Promise(r=>setTimeout(r)); segBuf = wsolaStretchSegment(audioBuf, start, end, 0.8); stretchCache.set(key, segBuf); setStatus('完成。','ok'); }
  } else {
    const sS=Math.floor(start*sr), eS=Math.floor(end*sr), len=Math.max(0,eS-sS), chs=audioBuf.numberOfChannels;
    segBuf = ctx.createBuffer(chs, len, sr);
    for(let c=0;c<chs;c++){ segBuf.getChannelData(c).set(audioBuf.getChannelData(c).subarray(sS, eS)); }
  }
  if (!segBuf) return;
  const node = ctx.createBufferSource(); node.buffer = segBuf; node.playbackRate.value = 1.0; node.connect(ctx.destination); node.start(0); currentSrc = node;
  node.onended = ()=>{ if(currentSrc===node) currentSrc=null; };
}
</script>
</body>
</html>
